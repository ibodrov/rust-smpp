use std::net::{TcpListener, TcpStream};
use std::io::prelude::*;
use std::io::BufReader;
use std::thread;
use std::result;

type Result<T> = result::Result<T, &'static str>;

fn to_u32(values: &[u8]) -> u32 {
    let mut out = 0;
    for &i in values {
        out = out << 4 | i as u32;
    }
    out
}

fn read_u32(stream: &mut TcpStream) -> Result<u32> {
    let buf : &mut [u8] = &mut [0u8; 4];
    match stream.read(buf) {
        Ok(0) => Err("EOF"),
        Ok(_) => Ok(to_u32(buf)),
        Err(_) => Err("Oops!")
    }
}

fn read_exact(stream: &mut TcpStream, len : usize) -> Result<&[u8]> {
    let buf : &mut Vec<u8> = &mut Vec::with_capacity(len);
    buf.resize(len, 0u8);
    match stream.read(buf) {
        Ok(i) if i < len => Err("Not enough bytes"),
        Ok(i) => Ok(buf),
        Err(_) => Err("Oops!")
    }
}

fn handle_client(mut stream: TcpStream) {
    loop {    
        let command_length = match read_u32(&mut stream) {
            Ok(v) => v,
            Err(e) => {
                println!("Error: {}", e);
                break;
            }
        };
        
        println!("< command_length: {}", command_length);

        let rest : &mut Vec<u8> = &mut Vec::new();
        rest.resize((command_length - 4) as usize, 0u8);
        
        match stream.read(rest) {
            Ok(len) => {
                println!("! got: {}", len);
            }

            Err(e) => {
                println!("Error: {}", e);
                break;
            }
        }
    }
}

fn main() {
    let listener = TcpListener::bind("0.0.0.0:1234").unwrap();

    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                thread::spawn(move || {
                    handle_client(stream);
                });
            }

            Err(e) => {
                println!("Error: {}", e);
            }
        }
    }

    drop(listener);
}
