use std::net::{TcpListener, TcpStream};
use std::io::prelude::*;
use std::thread;
use std::result;

type Result<T> = result::Result<T, &'static str>;

fn to_u32(values: &[u8]) -> u32 {
    let mut out = 0;
    for &i in values {
        out = out << 4 | i as u32;
    }
    out
}

fn read_u32(stream: &mut TcpStream) -> Result<u32> {
    match read_exact(stream, 4) {
        Ok(buf) => Ok(to_u32(&buf)),
        Err(_) => Err("Oops!"),
    }
}

fn read_exact(stream: &mut TcpStream, len: usize) -> Result<Vec<u8>> {
    let mut buf : Vec<u8> = Vec::with_capacity(len);
    buf.resize(len, 0);
    match stream.read(&mut buf) {
        Ok(_) => Ok(buf),
        Err(_) => Err("Oops!")
    }
}

fn handle_client(mut stream: TcpStream) {
    loop {
        let command_length = match read_u32(&mut stream) {
            Ok(v) => v,
            Err(e) => {
                println!("Error: {}", e);
                break;
            }
        };

        println!("< command_length: {}", command_length);

        let rest = read_exact(&mut stream, (command_length - 4) as usize);
        match rest {
            Ok(buf) => {
                println!("! got {} byte(s)", buf.len());
            }

            Err(e) => {
                println!("Error: {}", e);
                break;
            }
        }
    }
}

fn main() {
    let listener = TcpListener::bind("0.0.0.0:1234").unwrap();

    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                thread::spawn(move || {
                    handle_client(stream);
                });
            }

            Err(e) => {
                println!("Error: {}", e);
            }
        }
    }

    drop(listener);
}
